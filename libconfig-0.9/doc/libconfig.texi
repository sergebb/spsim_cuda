\input texinfo.tex    @c -*-texinfo-*-
@c 
@c %**start of header

@c All text is ignored before the setfilename.
@setfilename libconfig.info
@settitle libconfig @value{edition}

@set edition 0.9
@set update-month August 2006
@set update-date 1 @value{update-month}

@comment %**end of header

@tex
\global\emergencystretch = .3\hsize
@end tex

@setchapternewpage odd

@titlepage

@title libconfig
@subtitle A Library For Manipulating Structured Configuration Files
@subtitle Version @value{edition}
@subtitle @value{update-date}

@author Mark A.@: Lindner

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2005-2006  Mark A Lindner

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

@end titlepage

@contents

@ifnottex
@node Top
@comment  node-name,  next,  previous,  up
@top libconfig
@end ifnottex

@menu
* Introduction::
* Configuration Files::
* The C API::
* The C++ API::
* Configuration File Grammar::
* License::
* Function Index::
* Type Index::
@end menu

@node Introduction, Configuration Files, Top, Top
@comment  node-name,  next,  previous,  up
@menu
* Why Another Configuration File Library?::
* Using the Library from a C Program::
* Using the Library from a C++ Program::
* Compiling Using pkg-config::
@end menu
@chapter Introduction

@i{libconfig} is a library for parsing, manipulating, and writing
structured configuration files. The library features a fully
reentrant parser and includes bindings for both the C and C++
programming languages.

The library runs on modern POSIX-compilant systems, such as Linux,
Solaris, and Mac OS X (Darwin), as well as on Microsoft Windows
2000/XP and later (with either Microsoft Visual Studio or the GNU
toolchain via the MinGW environment).

@node Why Another Configuration File Library?, Using the Library from a C Program, , Introduction
@comment  node-name,  next,  previous,  up
@section Why Another Configuration File Library?

There are several open-source configuration file libraries available
as of this writing. This library was written because each of those
libraries falls short in one or more ways. The main features of
@i{libconfig} that set it apart from the other libraries are:

@itemize @bullet

@item A fully reentrant parser. Multiple configurations can be parsed in concurrent threads at the same time.

@item Both C @i{and} C++ bindings, as well as hooks to allow for the creation of wrappers in other languages.

@item A simple, structured configuration file format that is more
readable and compact than XML and more flexible than the obsolete but
prevalent Windows "INI" file format.

@item A low-footprint implementation (just 25K for the C library and 39K for the C++ library) that is suitable for memory-constrained systems.

@item Proper documentation.

@end itemize

@node Using the Library from a C Program, Using the Library from a C++ Program, Why Another Configuration File Library?, Introduction
@comment  node-name,  next,  previous,  up
@section Using the Library from a C Program

To use the library from C code, include the following preprocessor
directive in your source files:

@sp 1
@example
#include <libconfig.h>
@end example
@sp 1

To link with the library, specify @samp{-lconfig} as an argument to the
linker.

@node Using the Library from a C++ Program, Compiling Using pkg-config, Using the Library from a C Program, Introduction
@comment  node-name,  next,  previous,  up
@section Using the Library from a C++ Program

To use the library from C++, include the following preprocessor
directive in your source files:

@sp 1
@example
#include <libconfig.h++>
@end example
@sp 1

The C++ API classes are defined in the namespace @samp{libconfig}, hence the
following statement may optionally be used:

@sp 1
@example
using namespace libconfig;
@end example
@sp 1

To link with the library, specify @samp{-lconfig++} as an argument to
the linker.

@node Compiling Using pkg-config, , Using the Library from a C++ Program, Introduction
@comment  node-name,  next,  previous,  up
@section Compiling Using pkg-config

On UNIX systems you can use the @i{pkg-config} utility (version 0.20
or later) to automatically select the appropriate compiler and linker
switches for @i{libconfig}. Ensure that the environment variable
@samp{PKG_CONFIG_PATH} contains the absolute path to the
@file{lib/pkgconfig} subdirectory of the libconfig installation. Then,
you can link C programs with @i{libconfig} as follows:

@example
gcc `pkg-config --cflags libconfig` myprogram.c -o myprogram \
    `pkg-config --libs libconfig`
@end example
@sp 1

And similarly, for C++ programs:

@example
g++ `pkg-config --cflags libconfig++` myprogram.cpp -o myprogram \
    `pkg-config --libs libconfig++`
@end example

@sp 1
Note the backticks in the above examples.

@node Configuration Files, The C API, Introduction, Top
@comment  node-name,  next,  previous,  up
@menu
* Settings::
* Groups::
* Arrays::
* Lists::
* Integer Values::
* Floating Point Values::
* Boolean Values::
* String Values::
* Comments::
@end menu
@chapter Configuration Files

The @i{libconfig} library supports structured, hierarchical
configuration files. The configuration file format somewhat resembles C
source code.

A configuration file consists of a group of @dfn{settings}, which
associate names with values. A @dfn{value} can be one of the
following:

@itemize @bullet
@item A @dfn{simple value}: integer, floating-point number, boolean,
or string
@item An @dfn{array}, which is a sequence of simple values, all of which must have the same type
@item A @dfn{group}, which is a collection of settings
@item A @dfn{list}, which is a sequence of values of any type, including other lists
@end itemize

Consider the following configuration file for a hypothetical GUI
application, which illustrates all of the elements of the configuration
file grammar.

@sp 1
@cartouche
@example
# Example application configuration file

version = "1.0";

application:
@{
  window:
  @{
    title = "My Application";
    size = @{ w = 640; h = 480; @};
    pos = @{ x = 350; y = 250; @};
  @};

  list = ( ( "abc", 123, true ), 1.234, ( /* an empty list */) );

  books = ( @{ title  = "Treasure Island";
              author = "Robert Louis Stevenson";
              price  = 29.95;
              qty    = 5; @},
            @{ title  = "Snow Crash";
              author = "Neal Stephenson";
              price  = 9.99;
              qty    = 8; @} );

  misc:
  @{
    pi = 3.141592654;
    columns = [ "Last Name", "First Name", "MI" ];
    mask = 0x1FC3;
  @};
@};
@end example
@end cartouche
@sp 1

Settings which have only groups as ancestors can be uniquely identified
within the configuration by a @dfn{path}. The path is a dot-separated
sequence of group names beginning at a top-level group and ending at
the setting itself. For example, in our hypothetical configuration
file, the path to the @code{x} setting is
@code{application.window.pos.x}, while the path to the @code{version}
setting is simply @code{version}.

Since array and list elements do not have names, settings which are
within arrays and lists cannot be reached directly via a path.

The datatype of a value is determined from the format of the value
itself. If the value is enclosed in double quotes, it is treated as a
string. If it looks like an integer or floating point number, it is
treated as such. If it is one of the values @code{TRUE}, @code{true},
@code{FALSE}, or @code{false}, it is treated as a boolean. If it
consists of a comma-separated list of values enclosed in square
brackets, it is treated as an array. And if it consists of a
comma-separated list of values enclosed in parentheses, it is treated
as a list. Any value which does not meet any of these conditions
is considered invalid and results in a parse error.

All names are case-sensitive. They may consist only of alphanumeric
characters, dashes, and underscores, and must begin with a letter. No
other characters are allowed.

In C and C++, integer, floating point, and string values are mapped to
the types @code{long}, @code{double}, and @code{const char *},
respectively. The boolean type is mapped to @code{int} in C and
@code{bool} in C++.

The following sections describe the elements of the configuration file
grammar in additional detail.

@node Settings, Groups, , Configuration Files
@comment  node-name,  next,  previous,  up
@section Settings

An setting has the form:

@i{name} @b{=} @i{value} @b{;}

or:

@i{name} @b{:} @i{value} @b{;}

The trailing semicolon is required. Whitespace is not significant.

The value may be a simple value, an array, a group, or a list.

@node Groups, Arrays, Settings, Configuration Files
@comment  node-name,  next,  previous,  up
@section Groups

A group has the form:

@b{@{}
   @i{settings ...}
@b{@}}

Groups can contain any number of settings, but each setting must have
a unique name within the group.

@node Arrays, Lists, Groups, Configuration Files
@comment  node-name,  next,  previous,  up
@section Arrays

An array has the form:

@b{[} @i{value}@b{,} @i{value ...} @b{]}

An array may have zero or more elements, but the elements must all be
simple values of the same type.

@node Lists, Integer Values, Arrays, Configuration Files
@comment  node-name,  next,  previous,  up
@section Lists

A list has the form:

@b{(} @i{value}@b{,} @i{value ...} @b{)}

A list may have zero or more elements, each of which can be a simple
value, an array, a group, or another list.

@node Integer Values, Floating Point Values, Lists, Configuration Files
@comment  node-name,  next,  previous,  up
@section Integer Values

Integers can be represented in one of two ways: as a series of one or
more decimal digits (@samp{0} - @samp{9}), with an optional leading
sign character (@samp{+} or @samp{-}); or as a hexadecimal value
consisting of the characters @samp{0x} followed by a series of one or
more hexadecimal digits (@samp{0} - @samp{9}, @samp{A} - @samp{F},
@samp{a} - @samp{f}).

@node Floating Point Values, Boolean Values, Integer Values, Configuration Files
@comment  node-name,  next,  previous,  up
@section Floating Point Values

Floating point values consist of a series of one or more digits, one
decimal point, an optional leading sign character (@samp{+} or
@samp{-}), and an optional exponent. An exponent consists of the
letter @samp{E} or @samp{e}, an optional sign character, and a series
of one or more digits.

@node Boolean Values, String Values, Floating Point Values, Configuration Files
@comment  node-name,  next,  previous,  up
@section Boolean Values

Boolean values may have one of the following values: @samp{TRUE}, @samp{true},
@samp{FALSE}, @samp{false}.

@node String Values, Comments, Boolean Values, Configuration Files
@comment  node-name,  next,  previous,  up
@section String Values

String values consist of arbitrary text delimited by double
quotes. Literal double quotes can be escaped by preceding them with a
backslash: @samp{\"}. The escape sequences @samp{\\}, @samp{\f},
@samp{\n}, @samp{\r}, and @samp{\t} are also recognized, and have the
usual meaning. No other escape sequences are currently supported.

@node Comments, , String Values, Configuration Files
@comment  node-name,  next,  previous,  up
@section Comments

Three types of comments are allowed within a configuration:

@itemize @bullet

@item Script-style comments. All text beginning with a @samp{#} character
to the end of the line is ignored.

@item C-style comments. All text, including line breaks, between a starting
@samp{/*} sequence and an ending @samp{*/} sequence is ignored.

@item C++-style comments. All text beginning with a @samp{//} sequence to the
end of the line is ignored.

@end itemize

As expected, comment delimiters appearing within quoted strings are
treated as literal text.

Comments are ignored when the configuration is read in, so they are
not treated as part of the configuration. Therefore if the
configuration is written back out to a stream, any comments that were
present in the original configuration will be lost.

@node The C API, The C++ API, Configuration Files, Top
@comment  node-name,  next,  previous,  up
@chapter The C API

@tindex config_t
@tindex config_setting_t
This chapter describes the C library API. The type @i{config_t}
represents a configuration, and the type @i{config_setting_t} represents
a configuration setting.

@deftypefun void config_init (@w{config_t *@var{config}})
@deftypefunx void config_destroy (@w{config_t *@var{config}})

These functions initialize and destroy the configuration object @var{config}. 

@code{config_init()} initializes @var{config} as a new, empty
configuration.

@code{config_destroy()} destroys the configuration @var{config},
deallocating all memory associated with the configuration, but not
including the @i{config_t} structure itself.

@end deftypefun

@deftypefun int config_read (@w{config_t *@var{config}}, @w{FILE *@var{stream}})

This function reads and parses a configuration from the given
@var{stream} into the configuration object @var{config}. It returns
@code{1} on success, or @code{0} on failure; the
@code{config_error_text()} and @code{config_error_line()}
functions, described below, can be used to obtain information about the
error.

@end deftypefun

@deftypefun int config_read_file (@w{config_t *@var{config}}, @w{const char *@var{filename}})

This function reads and parses a configuration from the file named
@var{filename} into the configuration object @var{config}. It returns
@code{1} on success, or @code{0} on failure; the
@code{config_error_text()} and @code{config_error_line()} functions,
described below, can be used to obtain information about the error.

@end deftypefun

@deftypefun void config_write (@w{const config_t *@var{config}}, @w{FILE *@var{stream}})

This function writes the configuration @var{config} to the given
@var{stream}.

@end deftypefun

@deftypefun int config_write_file (@w{config_t *@var{config}}, @w{const char *@var{filename}})

This function writes the configuration @var{config} to the file named
@var{filename}. It returns @code{1} on success, or @code{0} on failure;
the @code{config_error_text()} and @code{config_error_line()}
functions, described below, can be used to obtain information about
the error.

@end deftypefun

@deftypefun {const char *} config_error_text (@w{const config_t *@var{config}})
@deftypefunx int config_error_line (@w{const config_t *@var{config}})

These functions, which are implemented as macros, return the text and
line number of the parse error, if one occurred during a call to
@code{config_read()}.

@end deftypefun

@deftypefun long config_lookup_int (@w{const config_t *@var{config}}, @w{const char *@var{path}})
@deftypefunx double config_lookup_float (@w{const config_t *@var{config}}, @w{const char *@var{path}})
@deftypefunx int config_lookup_bool (@w{const config_t *@var{config}}, @w{const char *@var{path}})
@deftypefunx {const char *} config_lookup_string (@w{const config_t *@var{config}}, @w{const char *@var{path}})

These functions locate the setting in the configuration @var{config}
specified by the path @var{path}. They return the value of the setting
on success, or a 0 or @code{NULL} value if the setting was not found or
if the type of the value did not match the type requested.

@end deftypefun

@deftypefun {config_setting_t *} config_lookup (@w{const config_t *@var{config}}, @w{const char *@var{path}})

This function locates the setting in the configuration @var{config}
specified by the path @var{path}. It returns a pointer to the
@code{config_setting_t} structure on success, or @code{NULL} if the
setting was not found.

@end deftypefun

@deftypefun long config_setting_get_int (@w{const config_setting_t *@var{setting}})
@deftypefunx double config_setting_get_float (@w{const config_setting_t *@var{setting}})
@deftypefunx int config_setting_get_bool (@w{const config_setting_t *@var{setting}})
@deftypefunx {const char *} config_setting_get_string (@w{const config_setting_t *@var{setting}})

These functions return the value of the given @var{setting}. If the
type of the setting does not match the type requested, a 0 or
@code{NULL} value is returned.

@end deftypefun

@deftypefun int config_setting_set_int (@w{config_setting_t *@var{setting}}, @w{long @var{value}})
@deftypefunx int config_setting_set_float (@w{config_setting_t *@var{setting}}, @w{double @var{value}})
@deftypefunx int config_setting_set_bool (@w{config_setting_t *@var{setting}}, @w{int @var{value}})
@deftypefunx int config_setting_set_string (@w{config_setting_t *@var{setting}}, @w{const char *@var{value}})

These functions set the value of the given @var{setting} to
@var{value}. On success, they return 1. If the setting does not match
the type of the value, they return 0.

@end deftypefun

@deftypefun int config_setting_get_format (@w{config_setting_t *@var{setting}})
@deftypefunx int config_setting_set_format (@w{config_setting_t *@var{setting}}, @w{int @var{format}})

These functions get and set the external format for the setting @var{setting}.

@tindex SettingFormat

The @var{format} must be one of the constants
@code{CONFIG_FORMAT_DEFAULT} or @code{CONFIG_FORMAT_HEX}. All settings
support the @code{CONFIG_FORMAT_DEFAULT} format. The
@code{CONFIG_FORMAT_HEX} format specifies hexadecimal formatting for
integer values, and hence only applies to settings of type
@code{CONFIG_TYPE_INT}.  If @var{format} is invalid for the given
setting, it is ignored.

@end deftypefun


@deftypefun {config_setting_t *} config_setting_get_member (@w{config_setting_t *@var{setting}}, @w{const char *@var{name}})

This function fetches the child setting named @var{name} from the group
@var{setting}. It returns the requested setting on success, or
@code{NULL} if the setting was not found or if @var{setting} is not a
group.

@end deftypefun

@deftypefun {config_setting_t *} config_setting_get_elem (@w{const config_setting_t *@var{setting}}, @w{int @var{index}})

This function fetches the element at the given @var{index} in the array
@var{setting}. It returns the requested setting on success, or
@code{NULL} if @var{index} is out of range or if @var{setting} is not an
array.

@end deftypefun

@deftypefun long config_setting_get_int_elem (@w{const config_setting_t *@var{setting}}, @w{int @var{index}})
@deftypefunx double config_setting_get_float_elem (@w{const config_setting_t *@var{setting}}, @w{int @var{index}})
@deftypefunx int config_setting_get_bool_elem (@w{const config_setting_t *@var{setting}}, @w{int @var{index}})
@deftypefunx {const char *} config_setting_get_string_elem (@w{const config_setting_t *@var{setting}}, @w{int @var{index}})

These functions return the value at the specified @var{index} in the
setting @var{setting}. If the setting is not an array or list, or if
the type of the element does not match the type requested, or if
@var{index} is out of range, they return 0 or @code{NULL}.

@end deftypefun

@deftypefun {config_setting_t *} config_setting_set_int_elem (@w{config_setting_t *@var{setting}}, @w{int @var{index}}, @w{long @var{value}})
@deftypefunx {config_setting_t *} config_setting_set_float_elem (@w{config_setting_t *@var{setting}}, @w{int @var{index}}, @w{double @var{value}})
@deftypefunx {config_setting_t *} config_setting_set_bool_elem (@w{config_setting_t *@var{setting}}, @w{int @var{index}}, @w{int @var{value}})
@deftypefunx {config_setting_t *} config_setting_set_string_elem (@w{config_setting_t *@var{setting}}, @w{int @var{index}}, @w{const char *@var{value}})

These functions set the value at the specified @var{index} in the
setting @var{setting} to @var{value}. If @var{index} is negative, a
new element is added to the end of the array or list. On success, they
return a pointer to the setting representing the element. If the
setting is not an array or list, or if the setting is an array and the
type of the array does not match the type of the value, or if
@var{index} is out of range, they return @code{NULL}.

@end deftypefun

@deftypefun {config_setting_t *} config_setting_add (@w{config_setting_t *@var{parent}}, @w{const char *@var{name}}, @w{int @var{type}})

This function adds a new child setting or element to the setting
@var{parent}, which must be a group, array, or list. If @var{parent}
is an array or list, the @var{name} parameter is ignored and may be
@code{NULL}.

The function returns the new setting on success, or @code{NULL} if
@var{parent} is not a group, array, or list; or if there is already a
child setting of @var{parent} named @var{name}; or if @var{type} is
invalid.

@end deftypefun

@deftypefun int config_setting_remove (@w{config_setting_t *@var{parent}}, @w{const char *@var{name}})

This function removes the setting named @var{name} from the parent
setting @var{parent}, which must be a group. Any child settings of the
setting are recursively destroyed as well.

The function returns 1 on success. If @var{parent} is not a group, or
if it has no setting with the given name, it returns 0.

@end deftypefun

@deftypefun {config_setting_t *} config_root_setting (@w{const config_t *@var{config}})

This function returns the root setting for the configuration
@var{config}. The root setting is an unnamed group.

@end deftypefun

@deftypefun {const char *} config_setting_name (@w{const config_setting_t *@var{setting}})

This function returns the name of the given @var{setting}, or
@code{NULL} if the setting has no name.

@end deftypefun

@deftypefun int config_setting_length (@w{const config_setting_t *@var{setting}})

This function returns the number of settings in a group, or the number of
elements in a list or array. For other types of settings, it returns
0.

@end deftypefun

@deftypefun int config_setting_type (@w{const config_setting_t *@var{setting}})

This function returns the type of the given @var{setting}. The return
value is one of the constants
@code{CONFIG_TYPE_INT}, @code{CONFIG_TYPE_FLOAT},
@code{CONFIG_TYPE_STRING}, @code{CONFIG_TYPE_BOOL},
@code{CONFIG_TYPE_ARRAY}, @code{CONFIG_TYPE_LIST}, or @code{CONFIG_TYPE_GROUP}.

@end deftypefun

@deftypefun void config_setting_set_hook (@w{config_setting_t *@var{setting}}, @w{void *@var{hook}})
@deftypefunx {void *} config_setting_get_hook (@w{const config_setting_t *@var{setting}})

These functions make it possible to attach arbitrary data to each
setting structure. The destructor function, if one has been supplied via
a call to @code{config_set_destructor()}, will be called by the library
to dispose of this data when the setting itself is deallocated.

@end deftypefun

@deftypefun void config_set_destructor (@w{config_t *@var{config}}, @w{void (*@var{destructor})(void *)})

This function assigns the destructor function @var{destructor} for the
configuration @var{config}. This function accepts a single @code{void *}
argument and has no return value. See @code{config_setting_set_hook()} above for more information.

@end deftypefun

@node The C++ API, Configuration File Grammar, The C API, Top
@comment  node-name,  next,  previous,  up
@chapter The C++ API

@tindex Config
@tindex Setting
This chapter describes the C++ library API. The class @code{Config}
represents a configuration, and the class @code{Setting} represents a
configuration setting.

@tindex ConfigException
The library defines a group of exceptions, all of which extend the
common base exception @code{ConfigException}.

@tindex SettingTypeException
A @code{SettingTypeException} is thrown when the type of a setting's
value does not match the type requested.

@tindex SettingNotFoundException
A @code{SettingNotFoundException} is thrown when a setting is not found.

@tindex SettingExistsException
A @code{SettingExistsException} is thrown when an attempt is made to add
a new setting with a non-unique name.

@tindex ParseException
A @code{ParseException} is thrown when a parse error occurs while
reading a configuration from a stream. The following methods are
available to obtain the error details:

@deftypemethod ParseException {const char *} getError ()
@deftypemethodx ParseException int getLine ()

These methods return the text and line number of the parse error.

@end deftypemethod

@tindex FileIOException
A @code{FileIOException} is thrown when an I/O error occurs while
reading/writing a configuration form/to a file.

The remainder of this chapter describes the methods for manipulating
configurations and configuration settings.

@deftypemethod Config {} Config ()
@deftypemethodx Config {} ~Config ()

These methods create and destroy @code{Config} objects. 

@end deftypemethod

@deftypemethod Config void read (@w{FILE *@var{stream}})
@deftypemethodx Config void write (@w{FILE *@var{stream}})

The @code{read()} method reads and parses a configuration from the given
@var{stream}. A @code{ParseException} is thrown if a parse error occurs.

The @code{write()} method writes the configuration to the given @var{stream}.

@end deftypemethod

@deftypemethod Config void readFile (@w{const char *@var{filename}})
@deftypemethodx Config void writeFile (@w{const char *@var{filename}})

The @code{readFile()} method reads and parses a configuration from the file
named @var{filename}. A @code{ParseException} is thrown if a parse error occurs. A
@code{FileIOException} is thrown if the file cannot be read.

The @code{writeFile()} method writes the configuration to the file
named @var{filename}. A @code{FileIOException} is thrown if the file cannot
be written.

@end deftypemethod

@deftypemethod Config {Setting &} lookup (@w{const std::string & @var{path}})
@deftypemethodx Config {Setting &} lookup (@w{const char * @var{path}})

These methods locate the setting specified by the path @var{path}. If
the requested setting is not found, a @code{SettingNotFoundException} is
thrown.

A @code{Setting} object may be assigned to a variable of type @i{bool}
if it is of type @code{TypeBoolean}; @i{int}, @i{unsigned int},
@i{long}, or @i{unsigned long} if it is of type @code{TypeInt};
@i{float} or @i{double} if it is of type @code{TypeFloat}; or
@w{@i{const char *}} or @i{std::string} if it is of type
@code{TypeString}.

The following example demonstrates this usage:

@cartouche
@example
long width = config.lookup("application.window.size.w");

bool splashScreen = config.lookup("application.splash_screen");
@end example
@end cartouche

Note that certain conversions can lead to loss of precision or
clipping of values, e.g., assigning a negative value to an @i{unsigned
int} (in which case the value will be treated as 0), or a
double-precision value to a @i{float}. The library does not treat
these lossy conversions as errors.

If the assignment is invalid due to a type mismatch, a
@code{SettingTypeException} is thrown.

@end deftypemethod

@deftypemethod Config {Setting &} {operator[]} (@w{int @var{index}})
@deftypemethodx Config {Setting &} {operator[]} (@w{const std::string &@var{name}})
@deftypemethodx Config {Setting &} {operator[]} (@w{const char *@var{name}})

A @code{Setting} object may be subscripted with an integer @var{index} if
it is an array or list, or with either a string @var{name} or an integer
@var{index} if it is a group. For example, the following expression would
return the string @samp{Last Name} when applied to the example
configuration in @ref{Configuration Files}.

If the setting is not an array, list, or group, a
@code{SettingTypeException} is thrown.

@sp 1
@cartouche
@example
Setting& setting = config.lookup("application.misc");
const char *s = setting["columns"][0];
@end example
@end cartouche

Iterating over a group's child settings with an integer index will
return the settings in the same order that they appear in the
configuration.

@end deftypemethod

@deftypemethod Config {Setting &} getRoot ()

This method returns the root setting for the configuration, which is a group.

@end deftypemethod

@deftypemethod Setting {Setting &} add (@w{const std::string & @var{name}}, @w{SettingType @var{type}})
@deftypemethodx Setting {Setting &} add (@w{const char *@var{name}}, @w{SettingType @var{type}})

These methods add a new child setting with the given @var{name} and
@var{type} to the setting, returning a reference to the new
setting. If the setting already has a child setting with the given
name, a @code{SettingExistsException} is thrown.

Once a setting has been created, neither its name nor type can be
changed.

@end deftypemethod

@deftypemethod Setting {Setting &} add (@w{SettingType @var{type}})

This method adds a new element to the setting, which must be of type
@code{TypeArray} or @code{TypeList}. If the setting is an array which
currently has zero elements, the @var{type} parameter (which must be
@code{TypeInt}, @code{TypeFloat}, @code{TypeBool}, or
@code{TypeString}) determines the type for the array; otherwise it
must match the type of the existing elements in the array.

The method returns the new setting on success. If @var{type} is a
simple type, tThe new setting will have a default value of 0, 0.0,
@code{false}, or @code{NULL}, depending on the type.

The method throws a @code{SettingTypeException} if the setting is not
an array or list, or if @var{type} is invalid.

@end deftypemethod

@deftypemethod Setting void remove (@w{const std::string & @var{name}})
@deftypemethodx Setting void remove (@w{const char * @var{name}})

These methods remove the child setting with the given @var{name} from
the setting, which must be a group. Any child settings of the setting
are recursively destroyed as well.

If the setting is not a group, a @code{SettingTypeException} is
thrown.  If the setting does not have a child setting with the given
name, a @code{SettingNotFoundException} is thrown.

@end deftypemethod

@deftypemethod Setting {const char *} getName ()

This method returns the name of the setting, or @code{NULL} if the
setting has no name.

@end deftypemethod

@deftypemethod Setting SettingType getType ()

@tindex SettingType
This method returns the type of the setting. The
@code{SettingType} enumeration consists of the following constants:
@code{TypeInt}, @code{TypeFloat}, @code{TypeString},
@code{TypeBoolean}, @code{TypeArray}, @code{TypeList}, or
@code{TypeGroup}.

@end deftypemethod

@deftypemethod Setting SettingFormat getFormat ()
@deftypemethodx Setting void setFormat (@w{SettingFormat @var{format}})

These methods get and set the external format for the setting.

@tindex SettingFormat

The @var{SettingFormat} enumeration consists of the following
constants: @code{FormatDefault}, @code{FormatHex}. All settings
support the @code{FormatDefault} format. The @code{FormatHex} format
specifies hexadecimal formatting for integer values, and hence only
applies to settings of type @code{TypeInt}. If @var{format} is invalid
for the given setting, it is ignored.

@end deftypemethod

@deftypemethod Setting int getLength ()

This method returns the number of settings in a group, or the number of
elements in a list or array. For other types of settings, it returns
0.

@end deftypemethod

@node Configuration File Grammar, License, The C++ API, Top
@comment  node-name,  next,  previous,  up
@chapter Configuration File Grammar

Below is the BNF grammar for configuration files. Comments are not part
of the grammar, and hence are not included here.

@sp 1
@example
configuration = setting-list | empty

boolean = "true" | "TRUE" | "false" | "FALSE"

empty =

setting-list = setting | setting-list setting

setting = name (":" | "=") value ";"

value = simple-value | array | list | group

value-list = value | value-list "," value

simple-value = boolean | integer | hex | float | string

simple-value-list = simple-value | simple-value-list "," simple-value

array = "[" (simple-value-list | empty) "]"

list = "(" (value-list | empty) ")"

group = "@{" (setting-list | empty) "@}"
@end example

@sp 2
Terminals are defined below as regular expressions:
@sp 1

@table @t
@item string
@code{\"([^\"]|(\\\"))*\"}
@item name
@code{[A-Za-z][-A-Za-z0-9_]*}
@item integer
@code{[-+]?[0-9]+}
@item hex
@code{0[Xx][0-9A-Fa-f]+}
@item float
@code{[-+]?([0-9]*)?\.[0-9]+([eE][-+]?[0-9]+)?}
@end table

@node License, Function Index, Configuration File Grammar, Top
@comment  node-name,  next,  previous,  up
@appendix License

@include LGPL.texi

@node Function Index, Type Index, License, Top
@comment  node-name,  next,  previous,  up
@unnumbered Function Index

@printindex fn

@node Type Index, , Function Index, Top
@unnumbered Type Index

@printindex tp

@bye
